#include "game_state.h"

#include <algorithm>
#include <functional>

Game_State::~Game_State()
{
    reset();
}
#include <iostream>
void Game_State::load_level(const std::string &level)
{
    reset();

    Level_Parser level_parser { "level_1.tmx" };

    sf::Texture bgTexture;
    if(!bgTexture.loadFromFile("level_1.png"))
        std::cerr << "Du suger kuk!";
    background.setTexture(bgTexture);
    bgTexture.setSmooth(false);

    gravity_constant = 9.82;

    auto tmp_objects { level_parser.get_objects() };
    objects.insert(objects.end(), tmp_objects.begin(), tmp_objects.end());

    std::cerr << objects.size();

    for (auto *object : objects)
    {
        if (object->get_shape().getTexture() != nullptr)
            texturated_objects.push_back(object);

        auto *simulatable_object
            { dynamic_cast<Simulatable*>(const_cast<Object*>(object)) };
        if (simulatable_object != nullptr)
            simulatable_objects.push_back(simulatable_object);

        auto *player_object { dynamic_cast<const Player*>(object) };
        if (player_object != nullptr)
            player = player_object;
    }
}

int Game_State::simulate()
{
    // Time elapsed since last simulation of simulatable objects
    float distance_modifier { (clock.restart().asMilliseconds() / 1000.0f) };

    // Number of simulations to run on each simulatable object
    int simulation_cycles {};

    // New objects generated by simulations
    std::vector<Object*> new_objects;

    // Size of <simulatable_objects>
    std::size_t stored_simulatable_objects_size
        { simulatable_objects.size() };

    // Prepare each simulatable object for simulation
    // and get the number of simulation cycles needed
    for (auto *simulatable_object : simulatable_objects)
    {
        int tmp_simulation_cycles
            { simulatable_object->prepare_simulate(
                                      distance_modifier, gravity_constant) };
        
        if (tmp_simulation_cycles > simulation_cycles)
        {
            simulation_cycles = tmp_simulation_cycles;
        }
    }

    // Simulate each simulatable object * simulation_cycles times
    // If a simulation generates new objects, add them to <new_objects>
    for (int _ {}; _ < simulation_cycles; ++_)
    {
        for (auto *simulatable_object : simulatable_objects)
        {
            auto tmp_new_objects
                { simulatable_object->simulate(simulation_cycles, objects) };

            if (!tmp_new_objects.empty())
            {
                new_objects.insert(new_objects.end(),
                                   tmp_new_objects.begin(),
                                   tmp_new_objects.end());
            }
        }
    }

    // Let each simulatable object perform its end-of-simulation code
    for (auto *simulatable_object : simulatable_objects)
        simulatable_object->end_simulate(objects);

    // Free memory of and remove objects marked for deletion from
    // <simulatable_objects>, <texturated_objects> and <objects>
    simulatable_objects.erase(
        std::remove_if(
            simulatable_objects.begin(),
            simulatable_objects.end(),
            std::mem_fn(&Simulatable::get_delete_status)),
        simulatable_objects.end());

    if (simulatable_objects.size() < stored_simulatable_objects_size)
    {
        texturated_objects.erase(
            std::remove_if(
                texturated_objects.begin(),
                texturated_objects.end(),
                std::mem_fn(&Object::get_delete_status)),
            texturated_objects.end());

        objects.erase(
            std::remove_if(
                objects.begin(),
                objects.end(),
                [](auto *object)
                {
                    bool delete_status { object->get_delete_status() };

                    if (delete_status)
                        delete object;

                    return delete_status;
                }),
            objects.end());
    }

    // Add each new object to <objects>
    // and, if texturated, to <texturated_objects>
    // and, if simulatable, to <simulatable_objects>
    for (auto *new_object : new_objects)
    {
        objects.push_back(new_object);

        if (new_object->get_shape().getTexture() != nullptr)
            texturated_objects.push_back(new_object);
            
        auto *simulatable_object = dynamic_cast<Simulatable*>(new_object);
        if (simulatable_object != nullptr)
            simulatable_objects.push_back(simulatable_object);
    }

    /*if (player->at_goal())
    {
        return 1;
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape))
    {
        return 2;
    }*/
    return 0;
}

void Game_State::set_zoom(sf::View &view)
{
    view.zoom(0.75);
}

void Game_State::set_view(sf::View &view)
{
    view.setCenter(player->get_shape().getPosition()
                   + player->get_shape().getSize());
}

void Game_State::reset()
{
    State::reset();
    simulatable_objects.clear();
    player = nullptr;
}